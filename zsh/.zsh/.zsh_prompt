#!/bin/bash

# Prompt Colors
  LIGHT_RED="%F{9}"
      WHITE="%F{white}"
 COLOR_NONE="%f"
     BG_RED="%K{red}"
    BG_BLUE="%K{blue}"
    BG_NONE="%k"
FONT_ITALIC=$'%{\x1b[3m%}'
FONT_NORMAL=$'%{\x1b[0m%}'

USER_COLOR="%F{142}"
PATH_COLOR="%F{109}"
BRANCH_COLOR="%F{208}"
BRANCH_STATUS_COLOR="%F{208}"
PROMPT_COLOR="%F{250}"
PROMPT_ERROR_COLOR="%F{167}"
VENV_BBOX_COLOR="%F{132}"

function set_path () {
    PATH_SH=%~
    if [[ "$PWD" == "$HOME" ]]; then
      PATH_SH="${PATH_COLOR}${PWD}${COLOR_NONE}"
      return
    fi

    PATH_SH="${PATH_COLOR}${PATH_SH}${COLOR_NONE}"
}

# check if local branch is up to date with remote
function git_up_to_date () {
    git diff --shortstat @{upstream} 2>/dev/null
}

# Determine the branch/state information for this git repository.
#    master!  => uncommited changes
#    master<  => branch behind of remote
#    master>  => branch ahead of remote
function set_git_branch() {
    BRANCH=
    if [ -d .git ] || git rev-parse --git-dir > /dev/null 2>&1 ; then
        local branch_v=$(git branch -v 2>/dev/null | grep "^* ")
        local branch

        case "$branch_v" in
          *"no branch, rebasing"* | *"(HEAD detached at"*)
            branch="($(echo -n $branch_v | cut -d"(" -f2 | cut -d")" -f1))"
            ;;
          *)
            branch=$(echo -n $branch_v | cut -d" " -f2)
            ;;
        esac

        local git_status=
        [[ $(git status --short 2>/dev/null) ]] && git_status="${git_status}!"

        echo -n $branch_v | grep -qs "behind"
        [[ $? -eq 0 ]] && git_status="${git_status}<"

        echo -n $branch_v | grep -qs "ahead"
        [[ $? -eq 0 ]] && git_status="${git_status}>"

        local git_symbol=""
        BRANCH=" ${BRANCH_COLOR}${git_symbol} $branch${BRANCH_STATUS_COLOR}${git_status}${COLOR_NONE}"
    fi
}

# Return the prompt symbol to use, colorized based on the return value of the
# previous command.
function set_prompt_symbol () {
    local symbol="λ"

    # if test -n "$SSH_TTY" || test -n "$SSH_CLIENT" ; then
    #     symbol="$"
    # fi

    # if [[ `whoami` == "root" ]] ; then
    #     symbol="#"
    # fi

    if test $1 -eq 0 ; then
        PROMPT_SYMBOL="%B${PROMPT_COLOR}${symbol}${COLOR_NONE}%b"
    else
        PROMPT_SYMBOL="${PROMPT_ERROR_COLOR}${symbol}${COLOR_NONE}"
    fi
}

# Indicate virtualenv or blackbox presence
#   venv
#   bbox
#   venv|bbox
function set_venv_bbox () {
  local venv_bbox_symbol=
  local prefix=
  local venv=
  local sep=
  local bbox=
  local bbox_keyring=

  [[ "${BLACKBOXDATA:-}" ]] && bbox_keyring=":${BLACKBOXDATA/keyrings\//}"

  [[ "${VIRTUAL_ENV:-}" ]] && venv="venv"

  # PROMPT_BLACKBOX needs to be set and exported in the .envrc (direnv) file of a repo's root dir
  [[ "${PROMPT_BLACKBOX:-}" ]] && bbox="bbox$bbox_keyring"

  [[ "${venv:-}" || "${bbox:-}" ]] && { prefix=" "; venv_bbox_symbol=""; }
  [[ "${venv:-}" && "${bbox:-}" ]] && sep="|"

  VENV_BBOX="${prefix}${VENV_BBOX_COLOR}${venv_bbox_symbol}${prefix}${venv}${sep}${bbox}${COLOR_NONE}"
}

# Set the hostname, highlighting the background if in ssh
function set_host () {
    P_HOST=%m
    if test -n "$SSH_TTY" || test -n "$SSH_CLIENT" ; then
        P_HOST="${BG_BLUE}${WHITE}${P_HOST}${COLOR_NONE}${BG_NONE}"
    fi
}

# Set the username and the hostname
function set_user () {
    P_USER=`whoami`
    P_USER="${P_USER}@"
    if [[ ${P_USER} == "root@" ]] ; then
        P_USER="${BG_RED}${WHITE}${P_USER}${COLOR_NONE}${BG_NONE}"
    fi
}

# Set the full bash prompt.
function set_prompt () {
    set_prompt_symbol $?
    set_path
    set_git_branch
    set_venv_bbox

    # Set the bash prompt variable.
    PS1=$'\n'"$PATH_SH"$FONT_ITALIC"$VENV_BBOX$BRANCH"$FONT_NORMAL$'\n'"$PROMPT_SYMBOL "
}

PROMPT_COMMAND=set_prompt
